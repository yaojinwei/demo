package proto;

/**
 * 建造者模式
 * 将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以有不同的表示。
 * 大概的意思，就是一套的构建过程可以有不同的产品（表示）出来。这些产品（表示）都按照这一套的构建过程被生产出来。
 *
 * 写代码也是如此，如果你遇到一个需要把控流程，但流程中的实现细节各有许多的方式，你可以采用建造者模式。
 * 用一个director类把控流程，而用许多不同的builder去建造流程中的细节并产生产品。这样，生产出来的产品是绝对不会出问题的。
 * 因为流程把控好了。你可以有多个builder去负责建造生产产品，而让director去把控流程。
 * 如果有新的产品，但是流程一致，你可以再扩张出一个builder来。这样，你看，建造者模式是不是很符合OCP原则呢。
 *
 *  建造者模式与抽象工厂模式有点相似，但是建造者模式返回一个完整的复杂产品，而抽象工厂模式返回一系列相关的产品；
 *  在抽象工厂模式中，客户端通过选择具体工厂来生成所需对象，而在建造者模式中，客户端通过指定具体建造者类型并指导Director类如何去生成对象，
 *  侧重于一步步构造一个复杂对象，然后将结果返回。如果将抽象工厂模式看成一个汽车配件生产厂，生成不同类型的汽车配件，
 *  那么建造者模式就是一个汽车组装厂，通过对配件进行组装返回一辆完整的汽车。
 *
 * 这种带有Director类的模式比较适合建造步骤和建造顺序确定的情况，否则Director类没有意义
 * 可通过Builder、Product、Director抽象出接口，进行三种不同维度的扩展，也就是建造者（富士康、冠捷），产品（台式机、笔记本）、生产过程（只能改变步骤内容或顺序，并不能增加或减少步骤）
 *  Builder接口类的设计影响着整体的扩展性，Builder接口类的方法不能增加或者减少，
 *
 * 使用建造者模式的好处
 * 1.使用建造者模式可以使客户端不必知道产品内部组成的细节。
 * 2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。
 * 3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。
 *
 * 使用建造者模式的场合:
 * 1.创建一些复杂的对象时，这些对象的内部组成构件间的建造顺序是稳定的，但是对象的内部组成构件面临着复杂的变化。
 * 2.要创建的复杂对象的算法，独立于该对象的组成部分，也独立于组成部分的装配方法时。
 * Created by yaojinwei on 2016/9/24.
 */
public interface Builder {
    void buildPartA();
    void buildPartB();
    void buildPartC();
    Product getResult();
}
